HMP File Format
(incomplete)

Under Construction


Document version 1
Written by Chris Ison



Copyright (C) 2014 WildMidi Developers
This document is licensed under the Creative Commons Attribution-ShareAlike 4.0 International License. To view a copy of this license, visit http://creativecommons.org/licenses/by-sa/4.0/.



Introduction

This document describes the HMI format as used by the WildMIDI project. It is not a complete description of the HMI file format and only those parts that are relevant to the WildMidi project are described here. Unfortunately we cannot answer questions about the format that are not described within this document. If you feel there is an error in this document please feel free to report it as a bug at https://github.com/Mindwerks/wildmidi/issues?direction=desc&sort=updated&state=open.



Description

// Header
{
    char header[] = "HMI-MIDISONG061595";
    char no_idea_1[210];
    char divisions[2]; // Stored as little endian
    char time_in_secs[4]; // this is incorrect but specs sighted stated this.
    char no_idea_2[12];
    char track_count;
    char no_idea_3[141];
    {
        // Repeat for number of tracks in track_count
        char track_offset[4]; // Stored as little endian;
    }
}

// Track Chunk
{
    char track_header[] = "HMI-MIDITRACK";
    char no_idea_4[74];
    char track_header_size[4];
    char no_idea_5[(track_header_size - 91];
    
    {
        // Repeat until end of track detected
        // ** NOTE ** Since track chunk has no length details you need to scan for end of track marker.
        char midi_delta[] = ???; // See MIDI Delta
        char midi_event[] = ???; // See MIDI Events
                                 // ** NOTE ** Note On event is slightly different to the normal MIDI note on event. See MIDI Events below.
    }
{

// Extra Data
{
    // Some HMI files have data after the tracks. Details are unknown about these bytes of data.
    char no_idea_6[] = ???;
}



MIDI Delta

This is a variable length value that determins how time (in MIDI ticks) is to pass before the following MIDI event is to be processed. Just like MIDI's variable length values, HMI files have bit 7 set on the each value in the variable length value except the last one. A value of 255 would be stored as 0x81 0x7f, or a value of 1 would be stored as 0x01 in the HMI variable length format.

    Examples:
    Delta of 255: < midi event > 0x81 0x7f < midi event>
    Delta of 127: < midi event > 0x7f < midi event >
    Delta of 65537: < midi event > 0x82 0x80 0x71 < midi event >



MIDI Events

The first byte of a midi events is split into 2 x 4bits. Bits 7-4 is the command while bits 3-0 is the MIDI channel the command is to occur on. For example 0x94 means do command 9 on channel 4. The only exception to this is where bits 7-4 = F in hexidecimal as these are a special group of commands.

The following commands are detailed in this document with the channel information (bits 3 - 0) set to 0, example 0x80. However the channel information could have a value anywhere from 0 to F in hexidecimal.

// Note Off
{
    // Does not exist in HMI specs sighted but added here just in case
    char cmd = 0x80;
    char note = 27; // Could be a value of 0 - 127
    char velocity = 0; // Could be a value of 0 - 127. Ignored by WildMIDI
}

// Note On
{
    char cmd = 0x90;
    char note = 32; // Could be a value of 0 - 127
    char velocity = 100; // Could be a value of 0 - 127. 
                         // If this value is 0 then it is treated as a note of
    char length[] = < variable length value >; // See MIDI Delta for example
}

// Aftertouch
{
    // Adjust the velocity of a note as if adjusting the preasure you are placing on the key of a preasure sensitive keyboard after you started playing it.

    char cmd = 0xa0;
    char note = 32; // Could be a value of 0 - 127
    char velocity = 100; // Could be a value of 0 - 127.
}

// Controller
{
    char cmd = 0xb0;
    char controller = 32; // Could be a value of 0 - 127
    char setting = 100; // Could be a value of 0 - 127 
}

// Patch
{
    /*
        Change the patch (or sound) used to play notes on the channel
     */
    char cmd = 0xc0;
    char change_patch = 32; // Could be a value of 0 - 127
}

// Preasure
{
    /*
        Adjust the velocity of all active notes on the channel as if adjusting the preasure you are placing on the keys of a preasure sensitive keyboard after you started playing them.
     */
    char cmd = 0xd0;
    char velocity = 32; // Could be a value of 0 - 127
}

// Pitch
{
    /*
        Adjust the pitch of a channel just like a pitch bend wheel does.
     */
    char cmd = 0xe0;
    char data_1 = 32; // Could be a value of 0 - 127
    char data_2 = 100; // Could be a value of 0 - 127.
}

// Sysex
{
    ** It is uncertain if sysex events will apepar in a HMI file but they have been included because it is possible **
    
    char cmd = 0xf0;
    // *** OR ***
    char cmd = 0xf7;

    char sysex_size[] = < variable length in MIDI file format >;
    char sysex_data[sysex_size]; // Ending with 0xf7
}

// HMI Events
{
    // This is undocumented in specifications others have put together so nothing other than the following is known about it.
    char cmd = 0xfe;
    
    {
        char type = 0x10;
        char data_1[2];;
        char size; // Could be anything from 0x00 to 0xff
        char data_2[size];
        char data_3[5];
    }
    // *** OR ***
    {
        char type = 0x15;
        char data[6];

    }
    // *** OR ***
    {
        char type;
        char data[2];
    }
}

// Meta Events
{
    char cmd = 0xff;
    char instruction = 0x02; // Could be 0 - 127
    char data_size[] = < variable length in MIDI file format >;
    char data[data_size];
}



